package hep.gear.api ;

/** A wrapper Class for PadRowLayout2D which converts 
 * between the actual pad layouts local coodinate system and the TPCs global
 * coordinate systems.
 * Adds some module appropriate functionality.
 * 
 *
 * original author F. Gaede, DESY 
 * @author M. Killenberg, (Bonn)  S. Turnbull, (Saclay/Carleton)
 * @version $Id: TPCModule.aid,v 1.1 2008-12-17 09:39:46 engels Exp $
 */

public interface TPCModule extends GearParameters, PadRowLayout2D {
    

    /** The type of the row layout: PadRowLayout2D.CARTESIAN or
     *  PadRowLayout2D.POLAR.
     */
    public int getPadLayoutType()  const;

    /** The shape of the pads, one of PadRowLayout2D.RECTANGLE (Keystone)
     * , PadRowLayout2D.DIAMOND, PadRowLayout2D.HEXAGON, 
     * PadRowLayout2D.CHEVRON
     */ 
    public int getPadShape()  const;

    /** The total number of pads on this module.
     */
    public int getNPads() const ;

    /** The number of rows on this module.
     */
    public int getNRows() const ;

    /** The row height in mm.
     */
    public double getRowHeight(int rowNumber) const ;
    
    /** The width of the pad at padIndex in mm (CARTESIAN) or radians (POLAR). 
     */
    public double getPadWidth( int padIndex ) const ;

    /** The center of the pad in global 2D coordinates, (x,y) or (r,phi).
     */
    public Vector2D getPadCenter(int padIndex) const ;

    /** The height of the pad in mm.
     */
    public double getPadHeight(int padIndex) const ;

    /** Indices of all pads in row \c rowNumber (row indices start from 0 at the
     * bottom (CARTESIAN) or at the center (POLAR)). 
     */
    public const int[]& getPadsInRow( int rowNumber) const ;

    /** Inherited from PadRowLayout2D, but generally not a useful measure
     *  in global coordinates, use getModuleExtent() instead.
     *  It is kept for backward compatibility, but only works if there is
     *  only one module in the end cap. The module must not have an angle
     *  or an offset, so its coordinate system is identical to the global
     *  one. 
     *  In case there is more than one module or there is an offset or angle
     *  it will throw a gear::Exception.
     */
    public const double[]& getPlaneExtent() const throws Exception;

    /** Maximal extent of the sensitive plane, defined relative to global 
     *  origin - [xmin,xmax,ymin,ymax] CARTESIAN or 
     *  [rmin,rmax,phimin,phimax] POLAR, may contain dead space due to
     *  conversion from local to global coordinate system.
     *
     *  The sensitive plane / amplification plane is the pad plane extended by a border (see
     *  getBorderWidth()).
     *  This allows the gas amplification structure to be larger than
     *  the pad plane, which in the case of a resistive coating
     *  will also produce signal on the pad plane for electrons arriving 
     *  within this border.
    
     *  Note: Amplification planes may overlap, 
     *  pad planes may not. 
     */
    public const double[]& getModuleExtent() const ;
    
    /** The module extent in local coordinates. This is the (local) pad plane,
     * enlarged by the border. As the plane extent in global coordinates does
     * not correspond to the actual shape, this is the only way to describe
     * the module extent without dead space (everything in the module extent
     * is considerred active, for instance due to a resistive coating which
     * causes signals even if there is no pad at the specific position).
     * \attention Returns LOCAL coordinates!   
     */
    public const double[]& getLocalModuleExtent() const ;
    
    /** The number of the row within this module that contains 
     *  the pad at padIndex - numbering starts at lowest r/y.
     */
    public int getRowNumber( int padIndex ) const ;

    /** The pad number (column) within the row  - numbering starts
     * at lowest phi/x.
     */
    public int getPadNumber( int padIndex ) const ;
    
    /** Create a padIndex for the given row and pad ( column ) number 
     */
    public int getPadIndex( int rowNum, int padNum ) const ;

    /** The index of the pad nearest to the given point in global 2D 
     * coordinates, (x,y,) or (r,phi).
     */
    public int getNearestPad( double c0, double c1 ) const ;

    /** The index of the right neighbour pad.
     */
    public int getRightNeighbour( int padIndex ) const ;

    /** The index of the left neighbour pad.
     */
    public int getLeftNeighbour( int padIndex ) const ;

    /** True if global coordinate (c0,c1) is within the given pad.
     */
    public boolean isInsidePad( double c0, double c1, int padIndex ) const ;

    /** True if global coordinate (c0,c1) is within any pad.
     */
    public boolean isInsidePad( double c0, double c1 ) const ;

    /** True if global coordinate (c0,c1) is within this modules
     * area of amplification/interest.  i.e. the pad plane plus the
     * surrounding border (see getBorderWidth() ).
     */
    public boolean isInsideModule( double c0, double c1 ) const ;

    /** The readout frequency in Hz.
     */
    public double getReadoutFrequency() const ;

    /** Returns the offest of Modules origin from the global origin
     *  A vector from Global (0,0) to module (0,0)
     */
    public const Vector2D & getOffset() const ;

    /** Returns the rotation of the module, in Rads, with respect 
     *  to the modules internal origin.
     */
    public double getAngle() const ;

    /** Returns the distance from a global coodinate (c0,c1), to a given
     *  pad's nearest boundery;   (c0,c1,index) 
     */
    public double getDistanceToPad( double c0, double c1 , int index) const ;

    /** Returns distastance from a global coodinate (c0,c1), to the 
     *  module's nearest boundery;   (c0,c1) 
     */
    public double getDistanceToModule( double c0, double c1 ) const ;

     /** Returns module ID
     */
    public int getModuleID() const ;   

    /**  Returns True if this and The given module * overlap pad regions
     *   Note: overlaping sensitive regions is ok, Just no two pads with
     * 	 shared physical space.
     */
    public boolean isOverlapping(TPCModule * testThisModule) const ; 
    
    /** Returns the amount by which the pad plane has been
     *  extended to produce the module plane.
     *
     *  In cartesian coordinates the plane is extended in x and y 
     *  by this ammount on all sides. 
     *
     *  In polar coordinates the 
     *  r-coordinate is extended by the borderwidth, in \f$\varphi\f$  it is 
     *  extended by an angle corresponding to \c borderWidth/rMin,
     *  so that the border is at least boderWidth at the inner radius
     *  and somewhat wider for larger  r.
     */
    public double getBorderWidth() const;

    /** Returns the TPCs coordinate type. Note that this is NOT the 
     *  coordinate type of the (local) pad plane on the module but 
     *  of the end plate this module is mounted in.
     */
    public int getTPCCoordinateType() const ;

    /** Returns a reference to the instance of the underlaying pad layout.
     * 	\attention This pad layout has it's own, local coordinate system!
     *  Usually it is not necessary to deal with the pad layout directly.
     *  It is preferred to use the modules memberfunctions, since the module
     *  is an implementation of  PadRowLayout2D which is implemented such that
     *  all coordinates are delivered in global coordinates.
     *  However there are cases it can be handy to have the local coordinates 
     *  available, for instance for debugging or to perform the coordinate
     *  transformations on the graphics processor for an event display.
     */   
    public const PadRowLayout2D& getLocalPadLayout() const ;

    /** Returns the global coordinates for a point in local coordinates.
     *	Usally you don't need this since all member functions of the module
     *  use global coordinates only. Please use for debugging only, for production
     *  code the usage is discourraged.
     */
    public Vector2D  globalToLocal(double c0,double c1) const ;

    /** Returns the local coordinates for a point in global coordinates.
     *	Usally you don't need this since all member functions of the module
     *  use global coordinates only. Please use for debugging only, for production
     *  code the usage is discourraged.
     */
    public Vector2D  localToGlobal(double c0,double c1) const ;
    
}
