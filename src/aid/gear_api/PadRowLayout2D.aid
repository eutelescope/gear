package hep.gear.api ;

/** Abstract description of a planar subdetector with pads (cells) 
 *  that are positioned in rows (circular or rectangular). 
 *  This can be used, e.g. to describe the layout of the GEMs in 
 *  a TPC or the FTD disks. The pads are indexed by row and column numbers
 *  in one 32-bit word.
 * 
 * @author F. Gaede, DESY
 * @version $Id: PadRowLayout2D.aid,v 1.5 2009-02-27 09:00:50 gaede Exp $
 */
public interface PadRowLayout2D {
    
    // Static constants (enums) for the type of the row layout 
@ifdef cpp
@cpp{
    static const int RECTANGULARPADROWLAYOUT = 1 ;
    static const int FIXEDPADSIZEDISKLAYOUT = 2 ;
    static const int FIXEDPADANGLEDISKLAYOUT = 3 ;
    static const int VERSATILEDISKROWLAYOUT = 4 ;
    static const int TPCMODULE = 100 ;

    static const int CARTESIAN = 1 ;
    static const int POLAR = 2 ;

    static const int RECTANGLE = 1 ;
    static const int DIAMOND = 2 ;
    static const int HEXAGON = 3 ;
    static const int CHEVRON = 4 ;
    
}@else
    public static const int RECTANGULARPADROWLAYOUT = 1 ;
    public static const int FIXEDPADSIZEDISKLAYOUT = 2 ;
    public static const int FIXEDPADANGLEDISKLAYOUT = 3 ;
    public static const int VERSATILEDISKROWLAYOUT = 4 ;
    public static const int TPCMODULE = 100 ;


    public static const int CARTESIAN = 1 ;
    public static const int POLAR = 2 ;

    public static const int RECTANGLE = 1 ;
    public static const int DIAMOND = 2 ;
    public static const int HEXAGON = 3 ;
    public static const int CHEVRON = 4 ;
@endif

    /** Returns a copy (clone) of this class. As PadRowLayout2D is an abstract
     *  interface with several implementation, this is used get a copy of the
     *  actual implementation without having to know what the actual
     *	implementation is.
     */
     public PadRowLayout2D* clone() const;

    /** \deprecated{
     *  As there now is more than one implementation for each coordinate type
     *  this is not sufficient to distinguish the implementations any more.
     *  Use getPadLayoutImplType() to get the implementation type.
     *  Use getCoordinateType() to get the type of the coordinate system.
     *  
     *  For backward compatibility this function returns
     *  PadRowLayout2D.CARTESIAN or PadRowLayout2D.POLAR, i. e. getCoordinateType().}
     */
    public int getPadLayoutType()  const;

    /** The type of the row layout implementation:
     *  PadRowLayout2D.RECTANGULARPADROWLAYOUT,
     *  PadRowLayout2D.FIXEDPADSIZEDISKLAYOUT, 
     *  PadRowLayout2D.FIXEDPADANGLEDISKLAYOUT
     *  or PadRowLayout2D.TPCMODULE.
     */
    public int getPadLayoutImplType()  const;

    /** The type of the row layouts coordinate system:
      *  PadRowLayout2D.CARTESIAN or
      *  PadRowLayout2D.POLAR.
      */
    public int getCoordinateType()  const;    

    /** The shape of the pads, one of PadRowLayout2D.RECTANGLE (Keystone), PadRowLayout2D.DIAMOND, 
     *	PadRowLayout2D.HEXAGON, PadRowLayout2D.CHEVRON
     */ 
    public int getPadShape()  const;

    /** The total number of pads.
     */
    public int getNPads() const ;

    /** The number of rows.
     */
    public int getNRows() const ;

    /** The row height in mm.
     */
    public double getRowHeight(int rowNumber) const ;
    
    /** The width of the pad at padIndex in mm (CARTESIAN) or radians (POLAR). 
     *  This is only the metal of the pad. Use getPadPitch() to get the
     *  effective pitch.
     */
    public double getPadWidth( int padIndex ) const ;

    /** The pitch (i. e. pad width plus gap)
     *  of the pad at padIndex in mm (CARTESIAN) or radians (POLAR). 
     */
    public double getPadPitch( int padIndex ) const ;

    /** The center of the pad in 2d coordinates, (x,y) or (r,phi).
     */
    public Vector2D getPadCenter(int padIndex) const ;

    /** The height of the pad in mm.
     */
    public double getPadHeight(int padIndex) const ;

    /** Indices of all pads in row rowNumber (row indices start from 0 at the
     * bottom (CARTESIAN) or at the center (POLAR)). 
     */
    public const int[]& getPadsInRow( int rowNumber) const ;

    /** Extent of the sensitive plane - [xmin,xmax,ymin,ymax] CARTESIAN or 
     *	[rmin,rmax,phimin,phimax] POLAR.
     */
    public const double[]& getPlaneExtent() const ;
    
    /** The number of the row that contains the pad at padIndex - numbering starts at r/y==0.
     */
    public int getRowNumber( int padIndex ) const ;

    /** The pad number (column) within the row  - numbering starts at phi/x == 0.
     */
    public int getPadNumber( int padIndex ) const ;
    

    /** Create a padIndex for the given row and pad ( column ) number 
     */
    public int getPadIndex( int rowNum, int padNum ) const ;

    /** The index of the pad nearest to the given point in 2d coordinates
     * (x,y,) or (r,phi).
     */
    public int getNearestPad( double c0, double c1 ) const ;

    /** The index of the right neighbour pad.
     */
    public int getRightNeighbour( int padIndex ) const ;

    /** The index of the left neighbour pad.
     */
    public int getLeftNeighbour( int padIndex ) const ;

    /** True if coordinate (c0,c1) is within the given pad.
     */
    public boolean isInsidePad( double c0, double c1, int padIndex ) const ;

    /** True if coordinate (c0,c1) is within any pad.
     */
    public boolean isInsidePad( double c0, double c1 ) const ;

    /** Returns the closest distance to the edge (outer border) of the pad.
     *  For coordinates inside the pad it returns 0.
     *  ATTENTION: This gives the distance to the effective pad, which is
     *  the relevant one, and not the distance to the metal. I. e. it uses
     *  the pad pitch and the row height instead of pad width and pad height. 
     */
    public double getDistanceToPad( double c0, double c1 , int padIndex ) const ;
}
